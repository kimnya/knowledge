<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>기본지식공부</h1>
    <ol>
      <li>
        이벤트 루프:
        <p>
          태스크를 끊임없이 처리 taskqueue에 쌓인 함수를 callstack으로<br />
          실시간으로 검사해서 옮김
        </p>
      </li>
      <li>
        불변성:
        <p>
          참조객체(object,array)의 값은 heapmemory에 저장되고 주소값을 가져와<br />
          사용하기 때문에 값을 변경할 수 있다. 값의 변경으로 코드의 예상치
          못한<br />
          오류와 복잡도를 방지하기 위해 지켜야 하는 룰 그것을 막기위해 spread<br />
          연산자,useState등으로 원본을 복사한 후 상태값을 변경한다. react의
          경우<br />
          callstack의 들어간 heapmemory의 주소값이 달라져야 상태변경을
          인식하기<br />
          때문에 사용하기도 한다.
        </p>
      </li>
      <li>
        useRef() 와 useEffect()
        <p>
          컴포넌트가 return이 되고 나면 함수가 실행이 안된다. <br />
          useRef() 사용시 useEffect()없이 사용하면 오류가 뜬다. <br />
          왜냐면 useRef()의 초기값이 null이기 때문에 태그를 참조하기 전까지
          비어있는 상태라 그렇다.<br />

          useEffect()는 렌더링 직후에 실행된다. 왜? 콜백큐는 콜스택이 비워진 후
          실행되기 때문이다.<br />

          setTimeout은 정확히 예약된 시간 뒤에 작동하지 않고 최소 예약된 시간
          뒤에 작동한다. 때문에 렌더링 직후 실행하고 싶은 함수가 있다면
          useEffect()안에 넣어둔다.<br />

          자식요소 안에서 리렌더링이 발생하면 부모요소는 리렌더링 되지 않는다.
          <br />
          부모요소 안에서 리렌더링이 발생하면 자식요소는 리렌더링 된다.
        </p>
      </li>
    </ol>
  </body>
</html>
