<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>기본지식공부</h1>
    <ul>
      <li>
        이벤트 루프:
        <p>
          태스크를 끊임없이 처리 taskqueue에 쌓인 함수를 callstack으로<br />
          실시간으로 검사해서 옮김
        </p>
      </li>
      <li>
        불변성:
        <p>
          참조객체(object,array)의 값은 heapmemory에 저장되고 주소값을 가져와<br />
          사용하기 때문에 값을 변경할 수 있다. 값의 변경으로 코드의 예상치
          못한<br />
          오류와 복잡도를 방지하기 위해 지켜야 하는 룰 그것을 막기위해 spread<br />
          연산자,useState등으로 원본을 복사한 후 상태값을 변경한다. react의
          경우<br />
          callstack의 들어간 heapmemory의 주소값이 달라져야 상태변경을
          인식하기<br />
          때문에 사용하기도 한다.
        </p>
      </li>
      <li>
        useRef() 와 useEffect():
        <p>
          컴포넌트가 return이 되고 나면 함수가 실행이 안된다. <br />
          useRef() 사용시 useEffect()없이 사용하면 오류가 뜬다. <br />
          왜냐면 useRef()의 초기값이 null이기 때문에 태그를 참조하기 전까지
          비어있는 상태라 그렇다.<br />

          useEffect()는 렌더링 직후에 실행된다. 왜? 콜백큐는 콜스택이 비워진 후
          실행되기 때문이다.<br />

          setTimeout은 정확히 예약된 시간 뒤에 작동하지 않고 최소 예약된 시간
          뒤에 작동한다. 때문에 렌더링 직후 실행하고 싶은 함수가 있다면
          useEffect()안에 넣어둔다.<br />

          자식요소 안에서 리렌더링이 발생하면 부모요소는 리렌더링 되지 않는다.
          <br />
          부모요소 안에서 리렌더링이 발생하면 자식요소는 리렌더링 된다.
        </p>
      </li>
      <li>
        useEffect()와useMemo():
        <p>
          스테이트에 계산 값을 저장하면 함수가 여러번 실행됐을때 리렌더링을
          방지해준다.<br />
          왜냐하면 스테이트값이 변경됐을때만 리렌더링 되기 때문이다.<br />
          useEffect를 사용하여 최적화 시킬 수 있다. inputNumber입력값이 변할때만
          계산 함수를 실행시키는 방법이다.<br />
          그런데 위 방법에서 useEffect()안 공간은 독립적이기 때문에 밖에서 안에
          있는 값을 참조하지 못한다. 때문에 새로운 useState를 생성하여
          참조해야한다 .<br />
          useMemo를 사용하면 같은 기능을 쉽게 처리할 수 있다.
        </p>
      </li>
      <li>
        클로저:
        <p>
          외부함수의 변수에 접근가능한 내부함수이다. <br />
          만들어진 환경을 기억한다는 것이 중요하다. <br />클로저를 포함한 함수를
          실행시켜 보면 마치 동적으로 파라미터값을 변화시키는것 같다.<br />
          하지만 이건 파라미터마다 새로운 환경을 갖기 때문에 발생하는 것이다.
        </p>
      </li>
      <li>
        mariaDB, mySQL:

        <p>
          데이터 베이스는 폴더다 데이터베이스에는 표가 들어있다. <br />차트
          테이블 coloumn 열과 row 행으로 이루어진다. <br />테이블데이터는
          SQL이란 언어로 조작할수 있다.<br />
          SQL은 크게 DDL과 DML로 나뉜다.<br />
          DDL은 DATA DEFINITION LANGUAGE이다. <br />DDL은 테이블의 구조를 다루는
          SQL이다. <br />칼럼이나 로우 갯수를 수정하거나 제약사항에 대해
          수정한다. <br />DML은 DTAA MANIPULATION LAGNUAGE이다. <br />DML은
          테이블의 데이터를 다루는 SQL이다.<br />
          1번데이터를 삭제하거나 데이터 내용을 수정한다.
        </p>
      </li>
      mySQL 환경설정
      <li>
        ---mySQL 테이블 대소문자 허용방법---
        <ol>
          <li>
            <p>
              xampp을 다운 받고 나면 콘솔?비슷한 창에 mysql config가 있다.<br />
              버튼을 누르면 my.ini라는 선택창이 나온다. 버튼을 누르면 메모장에
              mysql과 관련된 정보가 나온다.<br />
              메모 검색기능으로 [mysqld] 부분을 찾는다. 포트번호 위에 적는다.<br />
              lower_case_table_names =2를 적는다.<br />
              *대소문자를 알아서 구분을 허용해주는 명령어이다.
            </p>
          </li>
        </ol>
      </li>

      <li>
        ---mySQL 마스터 계정 생성법---
        <ol>
          <li>
            <p>
              mySQL을 실행 (start)한 후 shell버튼을 누른다. cmd창 같은게
              나온다.<br />
              mysql -u root을 입력한다.<br />
              GRANT ALL PRIVILEGES ON *.* TO 아이디@`%` IDENTIFIED BY
              `비밀번호`를 입력한다.<br />
              *모든 데이터베이스안에 테이블의 권한을 내가 만든 마스터 계정에게
              넘겨준다. <br />*마스터 계정으로 로그인 할땐 mysql -u 아이디 -p로
              입력한다.
            </p>
          </li>
        </ol>
      </li>

      <li>
        ---SQLyog 툴 다운로드 방법---
        <ol>
          <li>
            <p>
              https://github.com/webyog/sqlyog-community/wiki/Downloads로
              들어간다.<br />
              SQLyog Community Edition - 13.2.1 (64-Bit) or 최신버전을 다운로드
              받는다.
            </p>
          </li>
        </ol>
      </li>

      <li>
        ---SQLyog 툴 새연결 접속방법 ---
        <ol>
          <li>
            <p>
              파일 탭안에 새연결탭을 누른다.<br />
              새연결버튼을 누르고 root@localhost를 입력한다.<br />
              사용자이름을 마스테계정 아이디명으로 바꾼다. <br />비밀번호를
              마스테계정 비밀번호로 바꾼다. <br />연결누른다.
            </p>
          </li>
        </ol>
      </li>
      <li>
        ---SQLyog 툴 환경설정---
        <ol>
          <li>
            <p>
              도구탭안에 환경설정 탭을 누른다.<br />
              일반 탭에 메세지 탭에서 경고보기를 활성화해준다.<br />
              글꼴 & 편집기 설정에 들어가서 D2코딩 18px(sql편집기),14px(나머지)
              수정한다.<br />
              탭크기 4로 수정하고 삽입공간 활성화한다. <br />*D2코딩폰트는
              https://github.com/naver/d2codingfont/releases에 들어간다.<br />
              Assets부분에 가장 최신버전을 다운로드 받는다. <br />알집에서
              D2코딩폴더에 들어간다.<br />
              bold체만 더블클릭하여 설치한다.<br />
              데이터베이스는 테이블들의 묶음이다.<br />
              숙달할 시간이 부족하다. 한번 배울때 최대한 자세히 기록을 남기기로
              마음 먹었다.
            </p>
          </li>
        </ol>
      </li>
      <li>
        <p>
          # 전체 데이터베이스 리스팅<br />
          SHOW DATABASES;<br />

          # `mysql` 데이터 베이스 선택<br />
          USE mysql;<br />

          # 테이블 리스팅<br />
          SHOW TABLES;<br />

          # 특정 테이블의 구조<br />
          DESC `user`;<br />

          # `test` 데이터 베이스 선택<br />
          USE test;
          <br />
          # 테이블 리스팅<br />
          SHOW TABLES;<br />

          # 기존에 a1 데이터베이스가 존재 한다면 삭제<br />
          DROP DATABASE IF EXISTS `a1`;<br />
          *if 이하 덕분에 a1aDB가 존재하지 않아도 error를 방지할수 있다. <br />

          # 새 데이터베이스(`a1`) 생성<br />
          CREATE DATABASE `a1`;<br />

          # 데이터베이스(`a1`) 선택<br />
          USE `a1`;<br />

          # 데이터베이스 추가 되었는지 확인<br />
          SHOW DATABASES;<br />

          # 테이블 확인<br />
          SHOW TABLES;<br />

          # 게시물 테이블 article(title, body)을 만듭니다.<br />
          # VARCHAR(100) => 문자 100개 저장가능<br />
          # text => 문자 많이 저장가능<br />
          CREATE TABLE article (<br />
          title VARCHAR(100),<br />
          `body` TEXT );
          <br />

          # 잘 추가되었는지 확인, 리스팅과 구조까지 확인<br />
          SHOW TABLES;<br />
          DESC article;<br />

          # 데이터 하나 추가(title = 제목, body = 내용)<br />
          INSERT INTO article<br />
          SET title = '제목',<br />
          `body` = '내용';<br />

          # 데이터 조회(title 만)<br />
          SELECT title FROM article;<br />

          # 데이터 조회(title, body)<br />
          SELECT title, `body` FROM article; # 데이터 조회(body, title)<br />
          SELECT `body`, title FROM article;<br />

          # 데이터 조회(*)<br />
          SELECT * FROM article;<br />

          # 데이터 또 하나 추가(title = 제목, body = 내용)<br />
          INSERT INTO article<br />
          SET title = '제목',<br />
          `body` = '내용';<br />

          # 데이터 조회(*, 어떤게 2번 게시물인지 알 수 없음)<br />
          SELECT * FROM article;<br />

          # 테이블 구조 수정(id 칼럼 추가, first)<br />
          # 주의 : INT(10)이 10바이트라는 강사의 설명은 잘못 되었습니다. 그냥
          INT라고 쓰시면 됩니다.<br />
          ALTER TABLE article ADD COLUMN id INT FIRST;
          <br />
          # 데이터 조회(*, id 칼럼의 값은 NULL)<br />
          SELECT * FROM article;
          <br />
          # 기존 데이터에 id값 추가(id = 1, id IS NULL)<br />
          UPDATE article<br />
          SET id = 1<br />
          WHERE id IS NULL;<br />
          <br />
          # 데이터 조회(*, 둘다 수정되어 버림..)<br />
          SELECT * FROM article;
          <br />
          # 기존 데이터 중 1개만 id를 2로 변경(LIMIT 1)<br />
          UPDATE article<br />
          SET id = 2<br />
          LIMIT 1;<br />

          # 데이터 조회(*)<br />
          SELECT * FROM article;<br />

          # 데이터 1개 추가(id = 3, title = 제목3, body = 내용3)<br />
          INSERT INTO article<br />
          SET id = 3,<br />
          title = '제목3',<br />
          body = '내용3';<br />

          # 데이터 조회(*)<br />
          SELECT * FROM article;<br />

          # 2번 게시물, 데이터 삭제 => DELETE<br />
          DELETE FROM article<br />
          WHERE id = 2;<br />

          # 데이터 조회(*)<br />
          SELECT * FROM article;<br />

          # 날짜 칼럼 추가 => regDate DATETIME<br />
          ALTER TABLE article ADD COLUMN regDate DATETIME AFTER id;<br />

          # 테이블 구조 확인<br />
          DESC article;<br />

          # 데이터 조회(*, 날짜 정보가 비어있음)<br />
          SELECT * FROM article;<br />

          # 1번 게시물의 비어있는 날짜정보 채움(regDate = 2018-08-10
          15:00:00)<br />
          UPDATE article<br />
          SET regDate = '2018-08-10 15:00:00'<br />
          WHERE id = 1;<br />

          # 데이터 조회(*, 이제 2번 게시물의 날짜 정보만 넣으면 됩니다.)<br />
          SELECT * FROM article;
          <br />
          # NOW() 함수 실행해보기<br />
          SELECT NOW();<br />

          # 3번 게시물의 비어있는 날짜정보 채움(NOW())<br />
          UPDATE article<br />
          SET regDate = NOW()<br />
          WHERE id = 3;<br />

          # 데이터 조회(*)<br />
          SELECT * FROM article;<br />
        </p>
      </li>
      <li>
        mySQL 텍스트 방향 수정
        <p>
          문제가 발생했다<br />

          al데이터베이스가 만들어진 상태에서 DROP DATABASE IF EXISTS a1을 했을때
          무한로딩에 빠진다...<br />

          작업관리자로 완전히 끄고 있는데 이게 실무였다면 백업도 안된 상태에서
          종료해버리기엔 너무나 리스크가 커 보인다. 어떻게 해야하나? <br />

          1. 문제가 왜 일어나는지 알아야한다. <br />
          2. 백업 해둔다.
          <br />

          문제 해결법 1번<br />
          이후로도 drop database 하려면 무한로딩 걸리길래 table 하나하나 지우고
          database 지웠더니 지워짐<br />
          참고:https://velog.io/@doldoli/88gdkjrg<br />

          나같은 경우엔 XAMPP를 껐다가 다시 켜니 해결되긴 했다..
        </p>
      </li>
      <li>
        mySQL DDL 명령어 새로 알게된 것
        <p>
          ADD PRIMARY KEY(지정할 COLUMN) -중복되는 값이 들어오면 ERROR처리
          해준다. <br />AUTO_INCREAMENT 자동으로 숫자를 증가시켜준다. 자료형이
          INT형이어야 한다.<br />
          MODIFY COLUMN 내용을 수정해준다. <br />LIKE 이 조건과 같은 부분을
          출력해준다.<br />
          AND 조건이 모두 참인 것을 출력해준다 OR 조건 중 하나가 참인 것을
          출력해준다.<br />
          ORDER BY 원하는 기준으로 데이터를 정렬해준다. <br />기본형은
          올림차순이다.<br />
          ORDER BY COLUMN DESC 여기서 DESC는 내림차순을 뜻한다. <br />
        </p>
      </li>
      <li>
        <p>
          클래스 101 mySQL DML<br />

          그룹함수는 데이터를 그룹으로 만든다.<br />

          COUNT():<br />
          그룹에 속해있 데이터의 갯수를 반환<br />
          MAX():<br />
          그룹에 속해있는 데이터 중 가장 큰 수를 반환<br />
          MIN():<br />
          그룹에 속해있는 데이터 중 가장 작은 수를 반환<br />
          SUM():<br />
          그룹에 속해있는 데이터의 수를 모두 더해서 반환<br />
          AVG():<br />
          그룹에 속해있는 데이터의 수의 평균을 반환<br />
          TRUNCATE():<br />
          그룹에 속해있는 데이터의 소수점을 버림<br />
          GROUP_CONCAT():<br />
          그룹에 속해있는 모든 데이터 값을 쉼표(,)로 나눠서 보여줌<br />
          AS '칼럼명':<br />
          칼럼명을 AS 이후에 스트링으로 변경한다.<br />
          GROUP BY:<br />
          공통의 값을 가진 데이터만 모아서 그룹으로 만든다.
        </p>
      </li>
      <li>
        <p>
          클래스 101 mySQL INNER JOIN<br />

          INNER JOIN:<br />
          기준 테이블과 조인 테이블의 데이터가 있어야 출력된다.<br />
          ON을 설정하지 않으면 기준 테이블과 조인 테이블의 데이터의 모든 경우의
          수가 출력된다.<br />

          *ON은 두 테이블의 교집합을 찾아낼 결합 조건이다.<br />
        </p>
      </li>
    </ul>
  </body>
</html>
