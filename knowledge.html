<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>기본지식공부</h1>
    <ol>
      <li>
        이벤트 루프:
        <p>
          태스크를 끊임없이 처리 taskqueue에 쌓인 함수를 callstack으로<br />
          실시간으로 검사해서 옮김
        </p>
      </li>
      <li>
        불변성:
        <p>
          참조객체(object,array)의 값은 heapmemory에 저장되고 주소값을 가져와<br />
          사용하기 때문에 값을 변경할 수 있다. 값의 변경으로 코드의 예상치
          못한<br />
          오류와 복잡도를 방지하기 위해 지켜야 하는 룰 그것을 막기위해 spread<br />
          연산자,useState등으로 원본을 복사한 후 상태값을 변경한다. react의
          경우<br />
          callstack의 들어간 heapmemory의 주소값이 달라져야 상태변경을
          인식하기<br />
          때문에 사용하기도 한다.
        </p>
      </li>
      <li>
        useRef() 와 useEffect():
        <p>
          컴포넌트가 return이 되고 나면 함수가 실행이 안된다. <br />
          useRef() 사용시 useEffect()없이 사용하면 오류가 뜬다. <br />
          왜냐면 useRef()의 초기값이 null이기 때문에 태그를 참조하기 전까지
          비어있는 상태라 그렇다.<br />

          useEffect()는 렌더링 직후에 실행된다. 왜? 콜백큐는 콜스택이 비워진 후
          실행되기 때문이다.<br />

          setTimeout은 정확히 예약된 시간 뒤에 작동하지 않고 최소 예약된 시간
          뒤에 작동한다. 때문에 렌더링 직후 실행하고 싶은 함수가 있다면
          useEffect()안에 넣어둔다.<br />

          자식요소 안에서 리렌더링이 발생하면 부모요소는 리렌더링 되지 않는다.
          <br />
          부모요소 안에서 리렌더링이 발생하면 자식요소는 리렌더링 된다.
        </p>
      </li>
      <li>
        useEffect()와useMemo():
        <p>
          스테이트에 계산 값을 저장하면 함수가 여러번 실행됐을때 리렌더링을
          방지해준다.<br />
          왜냐하면 스테이트값이 변경됐을때만 리렌더링 되기 때문이다.<br />
          useEffect를 사용하여 최적화 시킬 수 있다. inputNumber입력값이 변할때만
          계산 함수를 실행시키는 방법이다.<br />
          그런데 위 방법에서 useEffect()안 공간은 독립적이기 때문에 밖에서 안에
          있는 값을 참조하지 못한다. 때문에 새로운 useState를 생성하여
          참조해야한다 .<br />
          useMemo를 사용하면 같은 기능을 쉽게 처리할 수 있다.
        </p>
      </li>
      <li>
        클로저:
        <p>
          외부함수의 변수에 접근가능한 내부함수이다. <br />
          만들어진 환경을 기억한다는 것이 중요하다. <br />클로저를 포함한 함수를
          실행시켜 보면 마치 동적으로 파라미터값을 변화시키는것 같다.<br />
          하지만 이건 파라미터마다 새로운 환경을 갖기 때문에 발생하는 것이다.
        </p>
      </li>
    </ol>
  </body>
</html>
